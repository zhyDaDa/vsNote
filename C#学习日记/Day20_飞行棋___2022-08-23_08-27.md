---
title: Day20_飞行棋___2022-08-23_08-27
date: 2022-08-23T08:27:54+08:00
tags:
    - C#学习笔记
    - study
---
目录
- [游戏头](#游戏头)
- [初始化地图](#初始化地图)
- [绘制地图](#绘制地图)

## 游戏头
- **作用**: 输出游戏初始界面
```
Console.ForegroundColor = ConsoleColor.Cyan;
Console.BackgroundColor = ConsoleColor.Black;
Console.WriteLine(@"
********************************************
********************************************
*******飞行棋游戏v1.0  By zhyDaDa***********
********************************************
********************************************
");
```
> `Console.ForegroundColor`和`Console.BackgroundColor`分别用于设置控制台输出的**前景色**和**背景色**  
> `@`的使用能按照原格式输出  
> 但要实现彩虹配色, 就得每输出一行, 就设置一遍前景色

## 初始化地图
- **作用**: 加载地图所需要的资源, 为画地图做准备
- 地图的数据采用***int***存储(***string***更困难一些)
- 数字变成字符串的过程, 就是初始化地图的过程
- 由于所有方法都需要操作Maps数组, 因此建议使用**静态字段**模拟全局变量
- 定义地图的方法: 把存在特殊关卡的位置全部标出来

```
/// <summary>
/// 初始化地图, 修改地图数组
/// </summary>
public static void InitiateMap()
{
    int[] luckyTurn = { 6, 23, 40, 55, 69, 83 };    //幸运轮盘
    AddSpecialToMaps(luckyTurn, 1);
    int[] landMine = { 5, 13, 17, 33, 38, 50, 64, 80, 94 };     //地雷
    AddSpecialToMaps(landMine, 2);
    int[] pause = { 9, 27, 60, 93 };    //暂停
    AddSpecialToMaps(pause, 3);
    int[] timeTunnel = { 20, 25, 45, 63, 72, 88, 90 };  //时空隧道
    AddSpecialToMaps(timeTunnel, 4);
}

/// <summary>
/// 输入一个数组, 把数组中的每个数字对应的地图位置
/// 修改为输入的数值
/// </summary>
/// <param name="array">元素是若干索引</param>
/// <param name="sign">要改为的数字</param>
public static void AddSpecialToMaps(int[] array, int sign)
{
    for (int i = 0; i < array.Length; i++)
    {
        Maps[array[i]] = sign;
    }
}
```

## 绘制地图
- 符号最好是全角的

```
/// <summary>
/// 画地图
/// </summary>
public static void DrawMap()
{
    Console.ForegroundColor = ConsoleColor.White;
    //画第一行
    for (int i = 0; i < 30; i++)
    {

        //如果两位玩家位置重合, 且都在地图上画一对尖括号
        if (PlayerPos[0] == PlayerPos[1] && PlayerPos[0]==i)
        {
            Console.Write("<>");
        }
        else if (PlayerPos[0] == i)
        {
            Console.Write("Ａ");
        }
        else if (PlayerPos[0] == i)
        {
            Console.Write("Ｂ");
        }
        else
        {
            switch (Maps[i])
            {
                case 0:
                    Console.Write("□");
                    break;
                case 1:
                    Console.Write("⨷");
                    break;
                case 2:
                    Console.Write("☆");
                    break;
                case 3:
                    Console.Write("∆");
                    break;
                case 4:
                    Console.Write("卐");
                    break;
            }
        }
    }


}//这是方法的括号
```

- 这里需要将方法抽离出来
- **值得注意的是**: 方法中最好不要打印控制台! 因此采用返回值的形式

```
/// <summary>
/// 返回要画出的一个格子
/// </summary>
/// <param name="i">对应的位置</param>
/// <returns>对应的格子的string</returns>
public static string TheStringOfTheMap(int i)
{
    string str = "";
    //如果两位玩家位置重合, 且都在地图上画一对尖括号
    if (PlayerPos[0] == PlayerPos[1] && PlayerPos[0] == i)
    {
        str = "§";
    }
    else if (PlayerPos[0] == i)
    {
        str = "Ａ";
    }
    else if (PlayerPos[0] == i)
    {
        str = "Ｂ";
    }
    else
    {
        switch (Maps[i])
        {
            case 0:
                //Console.ForegroundColor = ConsoleColor.White;
                str = "□";
                break;
            case 1:
                //Console.ForegroundColor = ConsoleColor.Green;
                str = "○";
                break;
            case 2:
                //Console.ForegroundColor = ConsoleColor.Red;
                str = "☆";
                break;
            case 3:
                //Console.ForegroundColor = ConsoleColor.Blue;
                str = "↓";
                break;
            case 4:
                //Console.ForegroundColor = ConsoleColor.DarkMagenta;
                str = "卐";
                break;
        }
    }

    return str;
}
```
> p.s. 事实上, 要想让这些奇怪的符号在控制台排列整齐, 需要调整字体为黑体(win11特有)  
> p.s.p.s. 那些个//是原本想要变换颜色的, 不知怎么的产生了奇怪的错位, 于是乎放弃  
> p.s.p.s.p.s. 说不定以后自己(or读者)有可能调试成功, 我记录一下我逐步调试的发现:  
> > 就是当变色之后, 下一个要打印的字符会把之前打印的所有字符当成是半角的字符  
> > ta就会跑到前面去, 接下来的字符就会和先前打印的重合造成重影

- 小竖行的处理相对简单, 只要打印空格就行
- 请注意空格数量

```
//换行
Console.WriteLine();

//画第一个数列(就一个)
for (int i = 30; i < 35; i++)
{
    for (int j = 0; j <= 28; j++)
    {
        Console.Write("  ");
    }
    Console.Write(TheStringOfTheMap(i));
    Console.WriteLine();
}
```