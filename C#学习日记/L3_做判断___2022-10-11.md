---
title: L3_做判断___2022-10-11
date: 2022-10-11T23:16:54+08:00
tags:
    - C语言学习笔记
    - study
---

\* 对应课程: 3.1.1 \~ 3.2.4   
目录
- [做判断](#做判断)
- [关系运算](#关系运算)
- [优先级](#优先级)
- [否则的话](#否则的话)
- [if再探](#if再探)
- [判断嵌套](#判断嵌套)
- [级联的if-else if](#级联的if-else-if)
- [多路分支 switch-case](#多路分支-switch-case)

- - -

## 做判断
条件判断用`if`, 语法如下
```
if(condition){
    code;
}
```

## 关系运算
计算两个值的关系称为 **关系运算**  
| 运算符  |    意义    |
| :-----: | :--------: |
|  `==`   |    相等    |
|  `!=`   |   不相等   |
| `>``>=` | 大于(等于) |
| `<``<=` | 小于(等于) |

**注意**: 
当两个值的关系与关系运算符的预期  
 + 相符, 结果为整数`1`
 + 不符, 结果为整数`0`

## 优先级
所有 <u>关系运算符</u> 的优先级 比 <u>算术运算</u> **低**  
   但是, 比 <u>赋值运算符</u> **高**

> `7 >= 3 + 4` 中先计算 `3 + 4`  
> `int r = a > 0` 中先计算 `a > 0`

判断相等与否的 `==`和`!=` 的优先级比其他关系运算符 **低**  
而 <u>连续的关系运算</u> 是 **从左到右进行的**  
> `5>3 == 6>4` 两个比较的结果都是`1`, 最后判断相等, 结果为`1`  
> `6>5>4` 先计算`6>5`得到结果`1`, 接着运算`1>4`, 因此结果为`0`  
> `a == b>0` 先计算`b>0`, 再判断其结果与`a`是否一致  

## 否则的话
与其他语言一样, 加一个`else`
```
if(condition){
    code 1;
}else{
    code 2;
}
```

## if再探
`if`语句后面 *未必* 要带上花括号`{}`  
如果要执行的只有**一行**语句, 可以不用花括号  

## 判断嵌套
观察一下两组代码  
```
/* find_max_1 */
int a, b, c;
scanf("%d %d %d", &a, &b, &c);

int max = 0;

if ( a>b ) {
    if( a>c ) {
        max = a;
    } else {
        max = c;
    }
} else {
    if ( b>c ) {
        max = b;
    } else {
        max = c;
    }
}

printf("The max is %d\n", max);
```

```
/* find_max_2 */
int a, b, c;
scanf("%d %d %d", &a, &b, &c);

int max = 0;

if ( a>b )
    if( a>c )
        max = a;
    else
        max = c;
else
    if ( b>c )
        max = b;
    else
        max = c;
    
printf("The max is %d\n", max);
```
两者在 *语法上* 完全相同  
但对于阅读代码的人来说会造成困扰  
这里需要注意两点:
 1. 即便有**缩进**, 也**不能**暗示嵌套关系  
 2. `else`会按<u>就近原则</u>去找最近的`if`


第二种写法显然存在着巨大的出错风险  
因此作为良好的编程习惯:  
> 在`if`或者`else`后面总是加上`{}`  
> 即便只有一条语句

## 级联的if-else if
```
if (condition_1){
    code_1;
} else if (conditon) {
    code_2;
} else {
    code_3
}
```
> 尽量别在级联的分支中做"实际操作"  
> 即, 最好是 **"单一出口"**

## 多路分支 switch-case
```
switch (condition) {
    case c_1:
        code_1;
        break;
    case c_2:
        code_2;
        break;
    case c_3:
        code_3;
        break;
    default: 
        code_4;
}
```
**注意**: 
 + `condition` 只能是整数型的结果
 + 各个 `c_i` 可以是常数, 也可以是*由常数构成*的表达式, 但一定**有确切结果**
 + `case`只是一个**路标**, 在运行完ta对应的代码后并不会使得分支结构跳出, 只有`break`可以
 + 一般来说, `case`和`break`都是配对的